下面是 **M1（最小可跑通骨架 + status API + 配置引导）** 的完整技术落地方案：包含**文件清单、职责边界、核心函数签名、DTO 字段、实现步骤与验收标准**。
（M1 的目标是：**服务能启动、API 协议稳定、空目录/半配置目录也能给出明确引导**。）

---

## M1 目标与验收标准

### 目标

1. `box_ai_tm server` 能启动 FastAPI（开发态支持 `--reload`）
2. `GET /api/health` 正常返回版本与时间
3. `GET /api/project/status` 能返回结构化状态：

   * 配置存在/缺失
   * 扫描到的文件列表（先不做深解析也行）
   * 统计项可先为 0（但字段结构要稳定）
   * 缺失时提供明确 hints（例如：如何生成配置）
4. 配置引导：

   * `GET /api/config/template` 返回模板
   * `POST /api/config/init` 可在 root 下生成配置（如果不存在）

### 硬约束（发布机制）

* 入口必须是 `src/**/tool.py`，并导出 `BOX_TOOL`，发布脚本会 import 读取并强校验结构。
* `BOX_TOOL` 的字段形状、校验规则遵循 tool_spec。

---

## M1 目录结构（只做必要文件）

建议按这个最小集落地（后续 M2/M3 再扩展）：

```
src/box_tools/ai_tm/
├─ tool.py
├─ __init__.py
├─ cli/
│  └─ server.py
├─ service/
│  ├─ app.py
│  ├─ errors.py
│  ├─ routes/
│  │  ├─ health.py
│  │  ├─ project.py
│  │  └─ config.py
│  └─ dto/
│     ├─ common.py
│     ├─ project.py
│     └─ config.py
└─ core/
   ├─ config.py
   ├─ scanner.py
   └─ analysis.py
```

> M1 **不需要** translate/normalize/runtime。先把“壳 + 协议 + 扫描 + 引导”跑通。

---

## 1) tool.py（CLI 入口 + BOX_TOOL 元数据）

### 职责

* 定义 `BOX_TOOL`
* 解析 CLI 参数
* 调用 `cli/server.py` 启动服务
* 不写任何业务逻辑

### BOX_TOOL（M1 推荐字段）

* `id`: `"box.ai_tm"`
* `name`: `"ai_tm"`（注意发布后脚本会加 `box_` 前缀到命令，但 name 建议就是工具命令本体）
* `category`: `"ai"`
* `summary`: `"本地 AI 翻译平台服务端：扫描项目并提供 HTTP API"`
* `usage`: 包含 `server` 子命令用法
* `dependencies`: `["fastapi", "uvicorn", "pydantic"]`（后续再加）
* `docs`: `"README.md"`

> 发布脚本会根据导入推断 dependencies 并写入 pyproject，但 BOX_TOOL.dependencies 也建议显式写，方便 README 汇总展示。

### CLI 参数（M1）

* `server`

  * `--host` 默认 `127.0.0.1`
  * `--port` 默认 `8765`
  * `--root` 默认当前工作目录
  * `--reload` 默认 False（开发态 True）

---

## 2) cli/server.py（启动 uvicorn）

### 职责

* 把 CLI 参数传入 app 工厂
* 启动 uvicorn

### 函数签名（建议）

* `def main(argv: list[str] | None = None) -> int:`
* `def run_server(host: str, port: int, root: str, reload: bool) -> int:`

---

## 3) service/app.py（FastAPI app 工厂）

### 职责

* 创建 FastAPI 实例
* 注入全局上下文（root 路径、版本号等）
* 挂载路由
* 注册统一错误处理（返回 Envelope）

### 关键设计（M1 最佳实践）

用 **app.state** 注入运行参数：

* `app.state.root: Path`
* `app.state.started_at: datetime`

### 函数签名（建议）

* `def create_app(root: str) -> FastAPI:`

---

## 4) service/dto（统一响应协议）

### 4.1 common.py

**Envelope（统一返回）**

字段定义（建议稳定）：

* `ok: bool`
* `data: Any | None`
* `error: ErrorInfo | None`

`ErrorInfo`：

* `code: str`
* `message: str`
* `details: dict | None`

并提供构造器：

* `def ok(data) -> Envelope`
* `def fail(code, message, details=None) -> Envelope`

---

## 5) service/errors.py（错误码与异常映射）

### 职责

* 定义错误码常量（M1 够用）
* 定义业务异常 `AiTmError`
* FastAPI exception handler，把异常转成 `Envelope.fail`

### M1 错误码（建议）

* `CONFIG_MISSING`
* `CONFIG_INVALID`
* `ROOT_NOT_FOUND`
* `FS_ERROR`

---

## 6) routes（M1 三个路由）

### 6.1 routes/health.py

`GET /api/health`

返回（data）：

* `name`: `"ai_tm"`
* `version`: `__version__`（先写死也行）
* `time`: ISO8601
* `root`: 当前 root（方便前端确认）

---

### 6.2 routes/config.py

#### `GET /api/config/template`

返回配置模板（字符串或 JSON）。建议返回结构化：

```json
{
  "path": "ai_tm.yaml",
  "content": "xxx..."
}
```

#### `POST /api/config/init`

入参（可选）：

* `overwrite: bool = false`

返回：

* 创建的配置路径
* 是否新建 / 是否已存在

---

### 6.3 routes/project.py

`GET /api/project/status`

M1 只要求：

* root 是否存在
* 配置是否存在/可读/校验结果
* 扫描文件列表（先不解析键值也行）
* 给出 hints（如果缺配置/缺文件）

---

## 7) core/config.py（配置加载 + 校验 + 模板）

### 职责

* `ai_tm.yaml` 的路径决策
* 加载配置
* 校验必要字段（M1 只校验“存在 + 字段基本类型”）
* 生成模板内容

### 配置字段（M1 最小）

* `fileType`: `"STRINGS"` 或 `"JSON"`
* `baseLocale`: `"en"`
* `coreLocales`: `["zh-Hans"]`
* `nonCoreLocales`: `["ja"]`
* `paths`:

  * `sourceDir`: `"."`（或 `"i18n"`）
  * `pattern`: `"**/*.strings"` / `"**/*.json"`

> M1 不要设计太复杂，先让 status 能工作。

### 函数签名（建议）

* `def config_path(root: Path) -> Path`
* `def template_text() -> str`
* `def load_config(root: Path) -> tuple[dict | None, list[str]]`

  * 返回 `(config_or_none, errors)`
* `def init_config(root: Path, overwrite: bool) -> tuple[Path, str]`

  * 返回 `(path, action)` action: `"created"|"exists"|"overwritten"`

---

## 8) core/scanner.py（扫描文件列表）

### 职责

* 根据 config.paths 扫描候选文件
* 输出文件清单（language + path）
* M1 不做深解析（只识别语言与路径）

### 语言识别策略（M1 够用）

先做一个朴素版本（后续再增强）：

* `.strings`：识别 `*.lproj/Localizable.strings` → language = `xxx`（取目录名去掉 `.lproj`）
* `.json`：约定 `xx.json` 或 `xx-YY.json`（取文件名）

### 函数签名（建议）

* `def scan_files(root: Path, cfg: dict) -> list[dict]`

  * 每项：`{"language": "zh-Hans", "path": "..."}`

---

## 9) core/analysis.py（M1 统计空壳）

### 职责

* 把扫描结果变成 ProjectStatus 的结构
* M1 统计可全为 0，但字段要齐

### 函数签名（建议）

* `def build_project_status(root: Path, cfg: dict | None, cfg_errors: list[str], files: list[dict]) -> dict`

---

## 10) ProjectStatus / DTO 字段定义（M1 固定契约）

### service/dto/project.py（建议的数据结构）

`ProjectStatusResponse.data`：

* `root: str`
* `config`:

  * `exists: bool`
  * `path: str`
  * `errors: list[str]`
* `project`（当 config 有效时，否则可为空对象或 null）:

  * `fileType: str`
  * `baseLocale: str`
  * `coreLocales: list[str]`
  * `nonCoreLocales: list[str]`
* `summary`:

  * `languages: int`
  * `files: int`
  * `missingKeys: int`
  * `redundantKeys: int`
  * `untranslatedKeys: int`
* `files: list[FileStatus]`

  * `language: str`
  * `role: "BASE"|"CORE"|"NON_CORE"|"UNKNOWN"`
  * `path: str`
  * `totalKeys: int`（M1=0）
  * `missingKeys: list[str]`（M1=[]）
  * `redundantKeys: list[str]`（M1=[]）
  * `untranslatedKeys: list[str]`（M1=[]）
* `hints: list[Hint]`

  * `code: str`
  * `message: str`

> 这样 Web UI 立刻能做页面：配置状态卡片 + 文件列表 + 统计概览。后续 M2/M3 只需要把 0 填成真实值。

---

## 11) M1 实现步骤（按顺序写代码最省心）

1. **建目录与空文件**（按上面的结构）
2. 写 `service/dto/common.py`（Envelope + ErrorInfo）
3. 写 `service/errors.py`（AiTmError + handler）
4. 写 `service/app.py`（create_app + mount routes）
5. 写 `routes/health.py`（最简单可用）
6. 写 `core/config.py`（template + init + load 校验）
7. 写 `routes/config.py`（template/init 两个接口）
8. 写 `core/scanner.py`（先实现 strings 的 lproj 识别 + json 的文件名识别）
9. 写 `core/analysis.py`（拼装 status 结构）
10. 写 `routes/project.py`（status API 串起来）
11. 写 `cli/server.py`（uvicorn 跑起来）
12. 写 `tool.py`（BOX_TOOL + server 子命令）

---

## 12) M1 验收用例（你写完就能自测）

### 用例 A：空目录

* 启动：`box_ai_tm server --root .`
* `GET /api/project/status`

  * `config.exists=false`
  * `hints` 包含 `CONFIG_MISSING`，提示可用 `/api/config/init`

### 用例 B：有配置，无翻译文件

* `POST /api/config/init`
* 再查 status：

  * config.exists=true
  * files=[] 或 summary.files=0
  * hints 提示“未扫描到目标文件”

### 用例 C：有配置 + 有示例文件

创建：

* `en.lproj/Localizable.strings`
* `zh-Hans.lproj/Localizable.strings`
  再查 status：
* files 至少列出两条（language + path）
* role 能识别 base/core

---

## 13) 关于 PyCharm “fastapi 飘红”问题（M1 顺手规避）

M1 最佳实践是：**开发环境用一个 venv**（不是 pipx 的运行环境），把 `fastapi/uvicorn` 装进去，PyCharm 解释器指到这个 venv。
发布安装与运行时再交给 pipx/发布机制。

---

如果你要我继续“直接进入实现”，下一步我会按上面 M1 清单把**每个文件的代码骨架（可直接运行）**一次性生成出来：

* `tool.py` + `cli/server.py` + `service/app.py` + 3 个 routes + core/config/scanner/analysis + DTO/错误处理
  写完你就能立刻启动并访问 `/docs`（FastAPI 自带 OpenAPI UI），M1 就算完工。
